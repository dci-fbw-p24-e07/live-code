# Advanced Data Types

## 04.06.25 - UUID, JSON, Arrays and Enum

- What are advanced data types?
- Examples of Advanced Data Types in PostgreSQL
- Implementing UUID as a Primary Key
- Using JSON to store object data
- Creating different types of arrays
- Creating a custom data type using Enum

### What are advanced data types?

- These are data types that allow you to store data in complex formats
- They usually build on the basic data types available or can be a combination of the basic data types
- They may differ from database to database.
- Handling the complex data types in source may require extra configurations

**Examples:**

1. JSON
2. UUID
3. Hstore
4. Array
5. Composite data types
6. BLOB
7. BYTEA

### UUID

- UUID stands for Universal Unique Identifier
- It is defined by RFC 4122 and other standards
- It is a value with 128-bit quantity generated by an algorithm that makes it unique in the known universe using the same algorithm.
- It is a sequence of 32 hexadecimal digits represented in groups separated by hyphens

    ```
    40e6215d-b5c6-4896-987c-f30f3678f608
    6ecd8c99-4036-403d-bf84-cf8400f67836
    3f333df6-90a4-4fda-8dd3-9485d27cee36
    ```

- Because of the uniqueness feature, you often find UUID being used in distributed systems because it generates better uniqueness than the `SERIAL` data type - which generates unique values within a single database table.
- To store UUID values you use the UUID data type in PostgreSQL

**Generating UUID values:**

```sql
SELECT gen_random_uuid();
```

**Creating a table with a UUID column:**

```sql 
-- Create customers table
CREATE TABLE customers (
    customer_id uuid DEFAULT gen_random_uuid(),
    first_name VARCHAR NOT NULL,
    last_name VARCHAR NOT NULL,
    email VARCHAR NOT NULL,
    phone VARCHAR NOT NULL,
    PRIMARY KEY (customer_id)
);

-- Insert data into customers table
INSERT  INTO customers(first_name, last_name, email, phone)
VALUES 
	('John', 'Smith', 'john.smith@mail.com', '+32112332876554'),
	('Jane', 'Smith', 'jane.smith@mail.com', '+32455325345634'),
	('Alex', 'Smith', 'alex.smith@mail.com', '+32243434343431')
RETURNING *;
```

### JSON

- JSON stands for JavaScript Object Notation
- It is a lightweight data interchange format that is readable for humans and simple for computers to parse
- It is based on two main data structures: objects and arrays

**Objects:**

- An unordered collection of key-value pairs enclosed in curly braces`{}`
- Each pair includes:
    1. A key which is a string surrounded by double quotes `"`
    2. A colon `:` that separates the key and value.
    3. A value can be a string a number or even an object

    ```json
    {"title": "The GodFather", "release_year": 2002, "length": 117}
    ```

    - The film object has 3 keys `title`, `release_year` and `length`

**Arrays:**

- An array is an ordered list of values enclosed in square brackets `[]`.
- The values do not have to be of the same type
- Additionally, an array may contain values of any valid JSON data type including objects and arrays

    ```json
    ["Chamber Italian", "Grosse Wonderful", "Airport Pollock"]
    ```

**Data types in JSON:**

- String: `"Joe"`
- Number: -1, 12, 35...
- Boolean: `true` and `false`
- Null: `null`

**PostgreSQL JSON types:**

- JSON - stores an exact copy of the JSON text
- JSONB - stores the JSON data in binary format

> In practice you should use JSONB to store data unless you have a specialized requirement such as retaining the ordering of keys in the JSON documents

**Creating a table with JSON field:**

```sql
-- Drop products table
DROP TABLE IF EXISTS products;

-- Create products table
CREATE TABLE products(
	product_id SERIAL PRIMARY KEY,
	product_name VARCHAR(255) NOT NULL,
	properties JSONB
);

-- Insert products data
INSERT INTO products(product_name, properties)
VALUES 
	('H&M V-Neck', '{"colour": "Red", "size": ["Small", "Medium", "Large", "Extra-Large"]}'),
	('Jet Jeans', '{"colour": "Black", "size": [32, 34, 36, 38, 40], "fabric": "Denim"}')
RETURNING *;
```

### Arrays

- In PostgreSQL , an array is a collection of elements of the same data type
- Arrays can be one-dimensional, multidimensional, or even nested.
- Every data type has its companion array type e.g `int` has an `int[]` array type, `char` has `char[]` array type.
- If you define a custom data type, PostgreSQL also creates a corresponding array type automatically for you.
- to define a column with an array:

    ```sql
    -- Define a one-dimensional array
    <column-name> <data-type> []

    -- Define a two dimensional array
    <column-name> <data-type> [][]
    ```

**Create an array field:**

```sql
CREATE TABLE orders(
    id uuid DEFAULT gen_random_uuid(),
    customer_id uuid,
    products TEXT [],
    PRIMARY KEY (id),
    FOREIGN KEY (customer_id)
    REFERENCES customers(customer_id) 
);
```

**Insert records into array:**

1. Using the ARRAY constructor:

    ```sql 
    INSERT INTO orders(customer_id, products)
    VALUES 
        ('a4b05888-32c5-43db-aab5-a25f4599ed7a', ARRAY ['Engine Oil', 'Spark Plugs', 'Oil Filter', 'Fan Belt']);
    ```

2. Using curly braces:

    ```sql
    -- Create an order using curly braces
    INSERT INTO orders(customer_id, products)
    VALUES 
        ('fefa5166-351e-47d0-9117-121dc9c9d196', '{"Plain White T-Shirt", "Cargo Pants", "All-Star Converse High-Tops", "Fanny Pack"}');
    ```

**Querying Array data:**

- You use subscripting to access an array element by specifying the index in square brackets `[]`
- By default, PostgreSQL uses one-based numbering for array elements. Meaning the first element starts with the number 1.

1. Retrieve all elements of an array:

    ```sql
    SELECT * FROM orders;
    ```

2. Retrieve a specific element in the array:

    ```sql
    -- Retrieve the second element in the array
    SELECT id, customer_id, products[2]
    FROM orders;
    ```

**Searching Array data:**

```sql
SELECT * 
FROM orders
WHERE 'Cargo Pants' = ANY (products);
```

### Enum

- This a custom data type that allows you to define a list of possible/accepted values for a column

**Syntax:**

```sql
-- Creating the custom data type
CREATE TYPE <enum-name>
AS ENUM(<value-1>, <value-2>, ....);

-- Defining the column in a table
<column-name> <enum-name>
```

- Specify the name of the enum after `CREATE TYPE`
- Provide a comma-separated list of values within parentheses.

> These values are **case-sensitive**

- If you attempt to insert or update a row with a value that does not exist in the list, PostgreSQL will raise an error.
- The ordering of values in an enum is the order in which you list them when you define the enum.

**Create an enum column:**

1. Create the enum:

    ```sql
    CREATE TYPE priority 
    AS ENUM('low', 'medium', 'high');
    ```

2. Create database table:

    ```sql
    -- Create the requests table
    CREATE TABLE requests(
        id SERIAL PRIMARY KEY,
        title VARCHAR(255) NOT NULL,
        req_priority PRIORITY NOT NULL,
        request_date DATE NOT NULL
    );
    ```

3. Insert data into table:

    ```sql
    -- Insert data into the requests table
    INSERT INTO requests(title, req_priority, request_date)
    VALUES 
        ('Create project draft', 'medium', '2025-06-04'),
        ('Upload invoices', 'high', '2025-06-03'),
        ('Cleanup unused documents', 'low', '2025-06-03');
    ```
